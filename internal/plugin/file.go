package plugin

import (
	"fmt"
	"text/template"

	"github.com/Neakxs/protoc-gen-authz/authorize"
	"github.com/Neakxs/protoc-gen-authz/internal/cfg"
	"github.com/google/cel-go/cel"
	"github.com/google/cel-go/checker/decls"
	"github.com/google/cel-go/interpreter"
	v1alpha1 "google.golang.org/genproto/googleapis/api/expr/v1alpha1"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

const (
	syncPackage        = protogen.GoImportPath("sync")
	authorizePackage   = protogen.GoImportPath("github.com/Neakxs/protoc-gen-authz/authorize")
	contextPackage     = protogen.GoImportPath("context")
	celPackage         = protogen.GoImportPath("github.com/google/cel-go/cel")
	declsPackage       = protogen.GoImportPath("github.com/google/cel-go/checker/decls")
	interpreterPackage = protogen.GoImportPath("github.com/google/cel-go/interpreter")
	parserPackage      = protogen.GoImportPath("github.com/google/cel-go/parser")
	codesPackage       = protogen.GoImportPath("google.golang.org/grpc/codes")
	statusPackage      = protogen.GoImportPath("google.golang.org/grpc/status")
)

var (
	importPaths = template.FuncMap{
		"syncIdent":        func(s string) protogen.GoIdent { return syncPackage.Ident(s) },
		"authorizeIdent":   func(s string) protogen.GoIdent { return authorizePackage.Ident(s) },
		"contextIdent":     func(s string) protogen.GoIdent { return contextPackage.Ident(s) },
		"celIdent":         func(s string) protogen.GoIdent { return celPackage.Ident(s) },
		"declsIdent":       func(s string) protogen.GoIdent { return declsPackage.Ident(s) },
		"interpreterIdent": func(s string) protogen.GoIdent { return interpreterPackage.Ident(s) },
		"parserIdent":      func(s string) protogen.GoIdent { return parserPackage.Ident(s) },
		"codesIdent":       func(s string) protogen.GoIdent { return codesPackage.Ident(s) },
		"statusIdent":      func(s string) protogen.GoIdent { return statusPackage.Ident(s) },
	}

	headerTemplate = template.Must(template.New("header").Parse(`
// Code generated by protoc-gen-go-authz. DO NOT EDIT.
// versions:
//  protoc-gen-go-authz	v` + PluginVersion + `
//  protoc 				v{{.Request.CompilerVersion.GetMajor}}.{{.Request.CompilerVersion.GetMinor}}.{{.Request.CompilerVersion.GetPatch}}
// source: {{.Source.Desc.Path}}

package {{.Source.GoPackageName}}
`))
	globalsTemplate = template.Must(template.New("globals").Parse(`
// Mapping of globally defined functions
var _{{.Source.GoDescriptorIdent.GoName}}_globalFunctions = map[string]string{
{{range $key, $value := .Configuration.Globals.Functions}}"{{ $key }}": ` + "`" + `{{ $value }}` + "`" + `,
{{end}}
}
`))
	messageAuthorizeTemplate = template.Must(template.New("messageAuthorize").Funcs(importPaths).Parse(`
{{if not .Rule}}
func (m *{{.Source.GoIdent.GoName}}) Authorize(ctx {{.QualifiedGoIdent (contextIdent "Context")}}) error {
	return nil
}
{{else}}
var (
	_{{.Source.GoIdent.GoName}}_celOnce {{.QualifiedGoIdent (syncIdent "Once")}} = {{.QualifiedGoIdent (syncIdent "Once")}}{}
	_{{.Source.GoIdent.GoName}}_celProgram {{.QualifiedGoIdent (celIdent "Program")}} = nil
)

func _Get_{{.Source.GoIdent.GoName}}_celProgram() ({{.QualifiedGoIdent (celIdent "Program")}}, error) {
	_{{.Source.GoIdent.GoName}}_celOnce.Do(func() {
		baseEnvOpts := []{{.QualifiedGoIdent (celIdent "EnvOption")}}{
			{{.QualifiedGoIdent (celIdent "Types")}}(&{{.QualifiedGoIdent (authorizeIdent "AuthorizationContext")}}{}),
			{{.QualifiedGoIdent (celIdent "DeclareContextProto")}}((&{{.Source.GoIdent.GoName}}{}).ProtoReflect().Descriptor()),
			{{.QualifiedGoIdent (celIdent "Declarations")}}(
				{{.QualifiedGoIdent (declsIdent "NewVar")}}(
					"_ctx", 
					{{.QualifiedGoIdent (declsIdent "NewObjectType")}}(string((&{{.QualifiedGoIdent (authorizeIdent "AuthorizationContext")}}{}).ProtoReflect().Descriptor().FullName())),
				),
			),
		}
		envOpts, err := {{.QualifiedGoIdent (authorizeIdent "BuildEnvOptionsWithMacros")}}(baseEnvOpts, map[string]string{
		{{range $key, $value := .Macros}}
			"{{$value}}": _{{$.Parent.GoDescriptorIdent.GoName}}_globalFunctions["{{$value}}"],
		{{end}}
		})
		if err != nil {
			return
		}
		env, err := {{.QualifiedGoIdent (celIdent "NewEnv")}}(envOpts...)
		if err != nil {
			return
		}
		ast, issues := env.Compile(` + "`" + `{{.Rule.Expr}}` + "`" + `)
		if issues != nil && issues.Err() != nil {
			return
		}
		pgr, err := env.Program(ast, {{.QualifiedGoIdent (celIdent "OptimizeRegex")}}({{.QualifiedGoIdent (interpreterIdent "MatchesRegexOptimization")}}))
		if err != nil {
			return
		}
		_{{.Source.GoIdent.GoName}}_celProgram = pgr
	})
	return _{{.Source.GoIdent.GoName}}_celProgram, nil
}

func (m *{{.Source.GoIdent.GoName}}) Authorize(ctx {{.QualifiedGoIdent (contextIdent "Context")}}) error {
	if pgr, err := _Get_{{.Source.GoIdent.GoName}}_celProgram(); err != nil {
		return err
	} else if pgr == nil {
		return nil
	} else {
		val, _, err := pgr.ContextEval(ctx, {{.QualifiedGoIdent (authorizeIdent "BuildProgramVars")}}(ctx, m))
		if err != nil {
			return err
		}
		if res, ok := val.Value().(bool); ok {
			if res {
				return nil
			} else {
				return {{.QualifiedGoIdent (statusIdent "Error")}}({{.QualifiedGoIdent (codesIdent "PermissionDenied")}}, "")
			}
		} else {
			return {{.QualifiedGoIdent (statusIdent "Error")}}({{.QualifiedGoIdent (codesIdent "Unknown")}}, "") 
		}
	}
}
{{end}}
`))
)

type file struct {
	*protogen.Plugin
	*protogen.GeneratedFile

	Configuration *cfg.Config
	Source        *protogen.File
}

func NewFile(p *protogen.Plugin, g *protogen.GeneratedFile, c *cfg.Config, f *protogen.File) *file {
	return &file{
		Plugin:        p,
		GeneratedFile: g,
		Configuration: c,
		Source:        f,
	}
}

func (f *file) Generate() error {
	if err := headerTemplate.Execute(f, f); err != nil {
		return err
	}
	if err := globalsTemplate.Execute(f, f); err != nil {
		return err
	}
	for i := 0; i < len(f.Source.Messages); i++ {
		if err := NewMessage(f.Plugin, f.GeneratedFile, f.Configuration, f.Source, f.Source.Messages[i]).Generate(); err != nil {
			f.Plugin.Error(err)
			return err
		}
	}
	return nil
}

func NewMessage(p *protogen.Plugin, g *protogen.GeneratedFile, c *cfg.Config, f *protogen.File, m *protogen.Message) *message {
	return &message{
		Plugin:        p,
		GeneratedFile: g,
		Configuration: c,
		Parent:        f,
		Source:        m,
		Rule:          proto.GetExtension(m.Desc.Options(), authorize.E_Rule).(*authorize.Rule),
	}
}

type message struct {
	*protogen.Plugin
	*protogen.GeneratedFile

	Configuration *cfg.Config
	Parent        *protogen.File
	Source        *protogen.Message
	Macros        []string
	Rule          *authorize.Rule
}

func (m *message) Generate() error {
	if m.Rule != nil {
		baseEnvOpts := []cel.EnvOption{
			cel.Types(&authorize.AuthorizationContext{}),
			cel.DeclareContextProto(m.Source.Desc),
			cel.Declarations(
				decls.NewVar("_ctx", decls.NewObjectType(string((&authorize.AuthorizationContext{}).ProtoReflect().Descriptor().FullName()))),
			),
		}
		testEnvOpts := baseEnvOpts
		for k := range m.Configuration.Globals.Functions {
			testEnvOpts = append(testEnvOpts, cel.Declarations(decls.NewFunction(k, decls.NewOverload(k, []*v1alpha1.Type{}, &v1alpha1.Type{TypeKind: &v1alpha1.Type_Primitive{Primitive: v1alpha1.Type_BOOL}}))))
		}
		testEnv, err := cel.NewEnv(testEnvOpts...)
		if err != nil {
			return err
		}
		testAst, issues := testEnv.Compile(m.Rule.Expr)
		if issues != nil && issues.Err() != nil {
			return issues.Err()
		}
		macros := findMacrosInAST(testAst, m.Configuration.Globals.Functions)
		macroMap := map[string]string{}
		for _, macro := range macros {
			macroMap[macro] = m.Configuration.Globals.Functions[macro]
		}
		envOpts, err := authorize.BuildEnvOptionsWithMacros(baseEnvOpts, macroMap)
		if err != nil {
			return err
		}
		env, err := cel.NewEnv(envOpts...)
		if err != nil {
			return err
		}
		ast, issues := env.Compile(m.Rule.Expr)
		if issues != nil && issues.Err() != nil {
			return issues.Err()
		}
		switch ast.ResultType().TypeKind.(type) {
		case *v1alpha1.Type_Primitive:
			if v1alpha1.Type_PrimitiveType(ast.ResultType().GetPrimitive().Number()) != v1alpha1.Type_BOOL {
				return fmt.Errorf("result type not bool")
			}
		default:
			return fmt.Errorf("result type not bool")
		}
		_, err = env.Program(ast, cel.OptimizeRegex(interpreter.MatchesRegexOptimization))
		if err != nil {
			return err
		}
		m.Macros = macros
	}
	if err := messageAuthorizeTemplate.Execute(m, m); err != nil {
		return err
	}
	return nil
}
